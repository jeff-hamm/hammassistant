esphome:
  name: outdoor-sense
  friendly_name: Outdoor Sense
  platformio_options:
    build_flags: -DBOARD_HAS_PSRAM
    board_build.arduino.memory_type: qio_opi
    board_build.f_flash: 80000000L
    board_build.flash_mode: qio 

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "aymyHnwThjWtKRnWuenPEfgrcoMUJLeNAXjT6ZjTxpo="

ota:
  - platform: esphome
    password: "726f8361498c39ebcd7a9355db724d16"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
#  ap:
#    ssid: "Outdoor-Sense Fallback Hotspot"
#    password: "LpNMxT7iBHaM"

captive_portal:

esp32_camera:
  external_clock:
    pin: GPIO10
    frequency: 20MHz
  i2c_pins:
    sda: GPIO40
    scl: GPIO39
  data_pins: [GPIO15, GPIO17, GPIO18, GPIO16, GPIO14, GPIO12, GPIO11, GPIO48]
  vsync_pin: GPIO38
  href_pin: GPIO47
  pixel_clock_pin: GPIO13
  name: 'Outdoor Camera'
  resolution: 720X1280
  jpeg_quality: 8
#  max_framerate: 1.0fps
#  idle_framerate: 0.2fps
  vertical_flip: true
  saturation: -1
#  horizontal_mirror: false
  brightness: 1 # -2 to 2
#  contrast: 1 # -2 to 2
#  special_effect: none
#  # exposure settings
#  aec_mode: auto
#  aec2: false
#  ae_level: 0
#  aec_value: 300
  # gain settings
#  agc_mode: auto
#  agc_gain_ceiling: 2x
#  agc_value: 0
  # white balance setting
#  wb_mode: auto




#switch:
#  - platform: gpio
#    name: "User_led1"
#    pin: 21
    

esp32_camera_web_server:
 - port: 8080
   mode: stream
 - port: 8081
   mode: snapshot

# i2s_audio:
#   i2s_lrclk_pin: GPIO42
#   i2s_bclk_pin: GPIO08

# microphone:
#  - platform: i2s_audio
#    adc_type: external
#    i2s_din_pin: GPIO41
#    pdm: true

external_components:
  - source: github://stas-sl/esphome-sound-level-meter  

i2s:
  ws_pin: GPIO42
  din_pin: GPIO41
  sample_rate: 16000            # default: 48000
  bits_per_sample: 16           # default: 32
  bck_pin: GPIO5
  use_apll: true                # default: false

sound_level_meter:
  # update_interval specifies over which interval to aggregate audio data
  # you can specify default update_interval on top level, but you can also
  # override it further by specifying it on sensor level
#  update_interval: 1s           # default: 60s

  # buffer_size is in samples (not bytes), so for float data type
  # number of bytes will be buffer_size * 4
#  buffer_size: 1024             # default: 1024

  # see your mic datasheet to find sensitivity and reference SPL.
  # those are used to convert dB FS to db SPL
  mic_sensitivity: -26dB        # default: empty
  mic_sensitivity_ref: 94dB     # default: empty

  update_interval: 30s  # to match original sensor.community firmware settings
  warmup_interval: 500ms
  groups:
    # - filters:
    #     - type: sos
    #       coeffs:
    #         # A-weighting:
    #         #       b0           b1            b2             a1            a2
    #         - [0.16999495, 0.741029, 0.52548885, -0.11321865, -0.056549273]
    #         - [1., -2.00027, 1.0002706, -0.03433284, -0.79215795]
    #         - [1., -0.709303, -0.29071867, -1.9822421, 0.9822986]
    - sensors:
        - type: eq
          name: LAeq_1s
          id: LAeq_1s
          unit_of_measurement: dBA
          update_interval: 1s
        - type: eq
          name: LAeq_1min
          id: LAeq_1min
          unit_of_measurement: dBA
        - type: max
          name: LAmax_125ms_1min
          id: LAmax_125ms_1min
          # I believe, previously 35ms was used in DNMS FW,
          # but later it was changed to 125ms
          window_size: 125ms
          unit_of_measurement: dBA
        - type: min
          name: LAmin_125ms_1min
          id: LAmin_125ms_1min
          window_size: 125ms
          unit_of_measurement: dBA
  # for flexibility sensors are organized hierarchically into groups.
  # each group can have any number of filters, sensors and nested groups.
  # for examples if there is a top level group A with filter A and nested
  # group B with filter B, then for sensors inside group B filters A
  # and then B will be applied:
  # groups:
  #   # group A
  #   - filters:
  #       - filter A
  #     groups:
  #       # group B
  #       - filters:
  #           - filter B
  #         sensors:
  #           - sensor X
  # groups:
  #   - sensors:
  #       - type: eq
  #         name: Leq_1s 
          
  #   - sensors:
  #     # 'eq' type sensor calculates Leq (average) sound level over specified period
  #     - type: eq
  #       name: LZeq_1s
  #       id: LZeq_1s
  #       # you can override updated_interval specified on top level
  #       # individually per each sensor
  #       update_interval: 1s
          
          
# sound_level_meter:
#   id: sound_level_meter1

#   # update_interval specifies over which interval to aggregate audio data
#   # you can specify default update_interval on top level, but you can also override
#   # it further by specifying it on sensor level
#   update_interval: 60s           # default: 60s

#   # you can disable (turn off) component by default (on boot)
#   # and turn it on later when needed via sound_level_meter.turn_on/toggle actions;
#   # when used with switch it might conflict/being overriden by
#   # switch state restoration logic, so you have to either disable it in
#   # switch config and then is_on property here will have effect, 
#   # or completely rely on switch state restoration/initialization and 
#   # any value set here will be ignored
#   is_on: true                   # default: true

#   # buffer_size is in samples (not bytes), so for float data type
#   # number of bytes will be buffer_size * 4
#   buffer_size: 1024             # default: 1024

#   # ignore audio data at startup for this long
#   warmup_interval: 500ms        # default: 500ms

#   # audio processing runs in a separate task, you can change its settings below
#   task_stack_size: 4096         # default: 4096
#   task_priority: 2              # default: 2
#   task_core: 1                  # default: 1

#   # see your mic datasheet to find sensitivity and reference SPL.
#   # those are used to convert dB FS to db SPL
#   mic_sensitivity: -26dB        # default: empty
#   mic_sensitivity_ref: 94dB     # default: empty
#  # additional offset if needed
# #  offset: 0dB                   # default: empty

#   # for flexibility sensors are organized hierarchically into groups. each group
#   # could have any number of filters, sensors and nested groups.
#   # for examples if there is a top level group A with filter A and nested group B
#   # with filter B, then for sensors inside group B filters A and then B will be
#   # applied:
#   # groups:
#   #   # group A
#   #   - filters:
#   #       - filter A
#   #     groups:
#   #       # group B
#   #       - filters:
#   #           - filter B
#   #         sensors:
#   #           - sensor X
#   groups:
    # group 1 (mic eq)
#    - filters:
        # for now only SOS filter type is supported, see math/filter-design.ipynb
        # to learn how to create or convert other filter types to SOS
 #       - type: sos
 #         coeffs:
            # INMP441:
            #      b0            b1           b2          a1            a2
#            - [ 1.0019784 , -1.9908513  , 0.9889158 , -1.9951786  , 0.99518436]

      # nested groups
      # groups:
      #   # group 1.1 (no weighting)
      #   - sensors:
      #       # 'eq' type sensor calculates Leq (average) sound level over specified period
      #       - type: eq
      #         name: LZeq_1s
      #         id: LZeq_1s
      #         # you can override updated_interval specified on top level
      #         # individually per each sensor
      #         update_interval: 1s

      #       # you can have as many sensors of same type, but with different
      #       # other parameters (e.g. update_interval) as needed
      #       - type: eq
      #         name: LZeq_1min
      #         id: LZeq_1min
      #         unit_of_measurement: dBZ

#             # 'max' sensor type calculates Lmax with specified window_size.
#             # for example, if update_interval is 60s and window_size is 1s
#             # then it will calculate 60 Leq values for each second of audio data
#             # and the result will be max of them
#             - type: max
#               name: LZmax_1s_1min
#               id: LZmax_1s_1min
#               window_size: 1s
#               unit_of_measurement: dBZ

#             # same as 'max', but 'min'
#             - type: min
#               name: LZmin_1s_1min
#               id: LZmin_1s_1min
#               window_size: 1s
#               unit_of_measurement: dBZ

#             # it finds max single sample over whole update_interval
#             - type: peak
#               name: LZpeak_1min
#               id: LZpeak_1min
#               unit_of_measurement: dBZ